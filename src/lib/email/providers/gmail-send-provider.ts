/**
 * Gmail Send Provider — implements EmailSendProvider for Gmail.
 *
 * Wraps the existing sendEmail() function from gmail/sync-service.ts.
 * Sends emails through the user's own Gmail account via OAuth.
 *
 * Gmail does NOT provide delivery tracking (no open/click/bounce webhooks),
 * so delivery status always returns "sent" after a successful send.
 */

import type { SupabaseClient } from "@supabase/supabase-js";
import type {
  GoogleConnectorConfig,
} from "@/lib/google/oauth";
import { ensureFreshGoogleToken } from "@/lib/google/oauth";
import { sendEmail } from "@/lib/gmail/sync-service";
import type {
  EmailSendProvider,
  SendOneParams,
  SendOneResult,
  DeliveryStatusResult,
} from "../send-provider";

/* ── Provider Implementation ──────────────────────────── */

export class GmailSendProvider implements EmailSendProvider {
  name = "gmail";
  private supabase: SupabaseClient;
  private orgId: string;
  private userId: string;

  constructor(config: Record<string, unknown>) {
    this.supabase = config.supabase as SupabaseClient;
    this.orgId = config.org_id as string;
    this.userId = config.user_id as string;

    if (!this.supabase || !this.orgId || !this.userId) {
      throw new Error(
        "GmailSendProvider requires supabase, org_id, and user_id in config",
      );
    }
  }

  /**
   * Send a single email through the user's Gmail account.
   *
   * Uses HTML content when available, with a plain-text fallback
   * auto-generated by the sendEmail() function.
   */
  async sendOne(params: SendOneParams): Promise<SendOneResult> {
    // Load Gmail connector config and refresh token
    const gmailConfig = await this.loadGmailConfig();

    const result = await sendEmail(
      gmailConfig,
      params.to,
      params.subject,
      params.htmlBody || params.textBody || "",
      undefined, // cc — not used by campaign sends
      params.htmlBody ? "text/html" : "text/plain",
    );

    if (!result.success) {
      throw new Error(result.error || "Gmail send failed");
    }

    return {
      messageId: result.messageId || `gmail_${Date.now()}`,
      status: "sent",
    };
  }

  /**
   * Gmail does not provide delivery tracking webhooks.
   * Returns "sent" for all successfully sent messages.
   */
  async getDeliveryStatus(_messageId: string): Promise<DeliveryStatusResult> {
    return { status: "sent" };
  }

  /**
   * Batch delivery status — returns "sent" for all.
   */
  async getBatchDeliveryStatus(
    messageIds: string[],
  ): Promise<Map<string, DeliveryStatusResult>> {
    const results = new Map<string, DeliveryStatusResult>();
    for (const id of messageIds) {
      results.set(id, { status: "sent" });
    }
    return results;
  }

  /* ── Private Helpers ────────────────────────────────── */

  /**
   * Load and refresh the Gmail OAuth config for this user's org.
   */
  private async loadGmailConfig(): Promise<GoogleConnectorConfig> {
    const { data: connector, error } = await this.supabase
      .from("data_connectors")
      .select("id, config")
      .eq("org_id", this.orgId)
      .eq("connector_type", "gmail")
      .eq("status", "connected")
      .maybeSingle();

    if (error || !connector?.config) {
      throw new Error("Gmail is not connected. Please connect Gmail first.");
    }

    const config = connector.config as GoogleConnectorConfig;

    // Ensure token is fresh
    const freshConfig = await ensureFreshGoogleToken(
      config,
      this.supabase,
      connector.id as string,
    );

    return freshConfig;
  }
}
